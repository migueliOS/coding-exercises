## Coding Exercise
### Testing the waters
> After checking out the project I decided to use my devices to test out both iPhone and iPad platforms, in addition to the simulators. So, I had to update the `Team` at the `Signing & Capabilities` to my own Apple Development Certificate and a meaningful bundle id for my scope with my frequently used prefix.

### First observations
* I want to give a first run in all plaforms (including Mac designed for iPad as it's part of the Supported Destinations).
* iPad (Mac); I can see the issue where it's showing a split screen for the Login Page, which usually should be prompted as a fullscreen view, since it's the entry point to the app and not further content should be presented. This might be a miss-usage of the pattern as Split-Views are meant to manage the presentation of 2 panes of content (primary on the left and detail on the right). Having a login screen on the left panel of a Split-View might be confusing from the user eperience point of view, specially if there's no content displayed on the right side.
* iPhone: The screen looks better, though it lacks a bit of hierarchy. A large title in the navigation bar says "Welcome" with two flat buttons, that don't look like buttons, both aligned to the edges respectively. And just like the iPad version, only supporting Dark Mode (dynamic colors) for the "native components" (that comes with it intrinsically). Making the navbar to change upon theme changing while the below "custom content" remains. All pretty inconsistent.

## Task 1
> I'm going to be describing my journey as I work on resolving this task.

* To resolve the iPad issues we can simply use the line `.navigationViewStyle(.stack)`. However, from iOS16+ onwards, we should be using `NavigationStack {}` as `navigationViewStyle` has been deprecated. As this project Deployment Target is iOS13, we can make a comment about the deprecation while using `navigationViewStyle` or what is better future proof when dropping older versions (and easier to migrate and scale):
```swift
      if #available(iOS 16.0, *) {
          NavigationStack {
              WelcomeView(koober: koober)
          }
      } else {
          // Fallback on earlier versions
          NavigationView {
              WelcomeView(koober: koober)
          }
          .navigationViewStyle(.stack)
      }
```
* The aligment and look of the buttons are quite off. I'm going to apply some UI adjustments to make it clearer and nicer for both platforms. Usually, login screens present these buttons in a vertical stack. This will make the view more cohesive, compact and intuitive in both platforms. Let's use a `VStack` in `SignInSignUpButtons`. Then, we just need to apply a consistent spacing for the `VStack` (no need for `Spacers`. (Note: ideally, these colors and measurements should be taken out from a Design System helper passed through environment to keep a consistent, maintainable and integral look and feel throughout the app).
* Also, for the colors: Ideally, we should have 2 backgorund colors for each theme "Light" and "Dark" and so for the text. Navigation bars are changing upon theme change while the custom content is not, bring up incosistencies in the design and possibly confusing the user or making it feel dodgy UI. Not to mention the important issues that contrast might have with the colors in terms of Accessibility. As I was suspecting, the existing eperience (white text on top of the brand color #00CEBC) does not meet AAA accessibility contrast compliance, nor even AA. The background is too light for a white color. On the other hand, black color meets perfectly the AAA on that background. In order to fix the `white text` issue for "Dark Theme" - which should be the one meant to be (white text always on dark themes unless the background is dark enough for specific elements). We could try and find a nice counterpart text color for the dark theme but we only have a single brand background color as well. So, instead of making up a new version of a background color for dark mode and so for the text on top of that background (which should be done by brand/design team), I'll just make sure accessibility is met by using a fixed "Light" theme (`Appearance Light` in the `info.plist`) and "black" for the text which passess AAA. This would fix the issue of "lack of brand colors for Dark Mode", while the design team would work on providing these for future revisions.
* The buttons still don't feel like buttons. Regular text usually uses `normal/regular` `weight`. If we don't apply `bold` to the buttons it's going to be harder to differentiate between static and interactive elements (blending with the content). Applying `bold` will make the interactions more intuitive, accessible and readable (specially for color blindness). On a personal note, I would make them looke even more like buttons with a shape and background (more native like), but so far, we depart from what's been provided and the assumption is to go with a plain (which is stil fair) style while meeting accessibility and making sure they look interactive.
* As the background is applied to the parent `WelcomeContentView.VStack`, we need to apply the background to the entire content including safe areas, so we're going to use a ZStack and a our brand background color for that. Just for the use case of the "Welcome Screen", I personally don't like having a `white` navigation bar adn the rest in the `brand` color. I'll probably change the navigation bar color too for consistency and feeling. For versions below to `iOS16` we would need to use `UINavigationBarAppearance` but I'll just mention this here and keep going to be concise and to th epoint. iOS16+ is tackled by using `toolbarBackground`.
* In order to ensure compatibility with smaller sized screens and Dynamic Type, we're going to enclose the content of the welcome screen within a scrollView that centeres its content just like the initial design (and it will strat scrolling as the content exceeds the scroll view bounds). For that I've created a `CenteredContentScrollView` that relys on a `ViewModifier` that reads the content's height by using a custom `PreferenceKey` that feed a `@Binding` property so we can center the content accordingly using `Spacers`.
* While launching to test this Task 1, couldn't help but to notice another inacessible text at the launch screen so I modified that using our new `Text` color.
* Finally, after the fix and verifying that the buttons were interactive and looking good on any platform, size class and orientation, I realised that the landscape display on iPhone was quite difficult to read and interact with (despite of having a scroll to view all content). I thought that it could be better to split the view in 2 parts, the logo on the left side and the buttons on the right. For what I created a utility view that switches between `VStack` and `HStack` only when we are on an `iPhone` device and `Landscape` orientation. As `iPad` has enough vertical room to show all content even on landscape and biggest dynamic type size. This way, our intended design remains consistent across majority of layouts, only adapting nicely when `iPhone` is on landscape.
## Task 2
- I can see there are no tests at all so let's start by creating a target for it (`UnitTest bundle`)
- Let's remove the default file and create our own XCTestCase swift file for testing `SignInUseCase`
- The class `SignInUseCase` is already using Dependency Injection because it depens on protocols `UserAuthenticationRemoteAPI` and `UserSessionStore` rathern than other classes. This makes testing easier because we can inject mock implementations there.
- However, we can improve testability and scalability (different methods of signing in) by extracting SignInUseCase into a protocol as well. We could also inject this into a `viewModel` in the future and make it flexible and testable. In addition to cleaner and more readable.
- `signIn()` and `store` should probably just be private as they're only use within `SignInUseCase` scope.
- I could see we can make use of the `fakes` created in `Koober.swift` file.
- Of course I had to made available (linked) all the involved files in the new Test target in order to be able to unit test them.
- Firstly, let's test the implementation of the new protocol. Then, let's test the following scenarios: Successful login, Failed unauthorised, Failed unknown, Successful but Store fails and some isolated test for Session store (already signed int and not signed in).
- It's great to have Fake implementations already there for both remote API and Session Store. However, in order to cover failure with both cases for `SignInError` on `RemoteAPI` we need to modify it with a few exra parameters `success: Bool` and `errorType: SignInError?`
- Same for the `FakeUserSessionStore`.
- 5 seconds should be sufficient time to wait for the expectation and cover all the sleeps that are included on the Fake implementations.
- Lastly, let's add a path to check if the SessionStore fails after successfull login.
- To verify the accuracy of my tests I run them repeatedly for 50 times and ensure it always succeeds. Specially when handling expectations and timeouts.
## Task 3
* I can see the action function `goToDropoffLocationSelectionScreen` is empty. So, let's implement going to `SelectDropoffLocationView`.
* I'm thinking of showcasing 2 approaches, one of them using `NavigationPath` and only for iOS16+ and the other one Presenting a `sheet`. Opportunity as well to show case how a deprecation could be handled to support new tech and backwards compatibility until the constraint versions are fully removed.
* I can see a similar issue with Split View on this screen, so we are going to fix it in the same way as we did with the OnboardingView from Task 1. For the NavigationPath approach, we don't need to include the content of the view within a NavigationStack. We also don't need to add a cancel button for this path as we will have the native `back` button (similar behaviour to Apple Settings App). On the other hand, I've used a `viewModel` to decouple the navigation logic and future additional logic from the UI and make this part easier to test through the `viewModel`.
* For the versions below iOS16 we have a sheet. To implement the `Cancel` action we are going to capture the `dismiss` environment system variable and call it within this function. Now, I realised that `dismiss` is only available from iOS15 onwards. As we are covering from iOS13 let's use a different variable which is `@Environment(\.presentationMode) var presentationMode`.
* For both approaches we need to encapsulate the content of `SelectDropOffLocationView` within a vertical stack view to render its content properly.
* I would say that for this particular use case where the user needs to, for a moment, go to an auxiliar screen to select/pick something, the best approach as per HiG is to use a modal (like the iOS16 below versions approach). Usually, navigation stack is for a series of steps requireds with an end result at the end. Though, as I mentioned before, we can see the pattern also in native Apple apps to also select or pick values and come back with the form filled with the new value. That's why I decided to showcase these 2 potential solutions and ellaborating the why.
